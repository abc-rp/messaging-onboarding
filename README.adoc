:experimental:
= Messaging stack on-boarding

NOTE: This is a work in progress document

This documentation is designed as a walk-through to onboard users to the ABC-RP messaging stack.
It will demonstrate an exemplary onboarding process as well as linking to further reading regarding the APIs and standards employed.

Efforts have been made to link to rather than duplicate other documentation.

== Overview

The ABC-RP messaging stack is based on the following projects and standards:

* link:https://mqtt.org/[MQTT] (Network protocol)
* link:https://github.com/theodi/BDNS[Building Device Naming Standards initiative (BDNS)] (Device naming)
* link:https://brickschema.org/[Brick Schema] (Point naming)
* link:https://github.com/faucetsdn/udmi[UDMI] (Payload format)
* link:https://github.com/faucetsdn/udmi_site_model[UDMI Site Model] (Project Site Model)

== Pre-requisites

=== Command line tools

The usual command line tools:

* [command]`mqtt` - aka link:https://github.com/hivemq/mqtt-cli[MQTT CLI]

== Concepts

This section explains some key concepts of the ABC-RP messaging infrastructure.

=== Applications

Applications scope all elements that belong together. Like devices, data, and integrations.

Applications are isolated from each other.

=== Devices

Each device is owned by exactly one application and has at least one ID to identify it. Device IDs are unique in the scope of an application.

=== Glossary
* *Channel* – The channel is an indicator of the device to which *data stream* the event belongs.
  Depending on the protocol, this can be set by the device, or generated by the protocol endpoint.
  For example: In UDMI these would map to `pointset` or `system`.
* *Device* – A device, connecting to the system. Might also be a *gateway device*, communicating on behalf of other
  devices (edge node). Might also be another *service*, providing connectivity for either devices
  (e.g. The Things Network, Sigfox).
* *Gateway device* – A device (for example a non IP enabled device) might use another device for sending data to the
  cloud. So there is one device the data originates from, and (optionally a different) device the connection
  originates from. If the data is coming from a different device then the connection, the latter device is called a
  *gateway device*.
* *User* – A person accessing the system. Identified by some kind of credentials. Might also be another service.
  Alternative terms: "account".
* *Application* – A construct to isolate, scope devices into a group. Data and configuration is not shared between different
  applications. Alternative terms: "(device) scope", "namespace" and "tenant".
* *Instance* – An instance of the whole deployment, serving multiple applications.
* *Cluster* – A Kubernetes cluster, possibly running other workload as well.

=== Endpoint hostnames

End point hostnames will be provided by ABC-RP as part of your onboarding information.
Example values are shown below:

* `mqtt.facilities.abc-rp.com:443` For devices connecting to MQTT Protocol Endpoint

=== Encryption

All our endpoint only support encrypted certificate based communication.  This is true even when using `(Username)/password` for authentication.

Typically we will use link:https://letsencrypt.org/[Let's Encrypt] TLS certificates which get refreshed regularly.  As such you should set up your devices to trust the link:https://www.identrust.com/dst-root-ca-x3[DST Root CA X3] certificate not the one that is currently on our server as this will be replaced.

=== Application ID

You will be provided a Application ID as part of your onboarding information.
This is used internally to manage data and data streams into strictly isolated subsets.  

Application IDs:

* Must be DNS labels as defined by link:https://tools.ietf.org/html/rfc1123[RFC1123]
* This is necessary to ensure that we can use this ID for Kubernetes resources as well
* Also see link:https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names[Kubernetes Docs]

An example Application ID might be:

* `swansea-iot`

=== Device ID

link:https://github.com/theodi/BDNS[Building Device Naming Standards initiative (BDNS)]

Device naming should follow the emerging [acronym]`BDNS` standard.
The specification can be found on this link:https://github.com/theodi/BDNS/blob/master/BDNS_Specification_naming_syntax.md[Github page].
Also follow the current link:https://github.com/theodi/BDNS/blob/master/BDNS_Abbreviations_Register.csv[Abbreviations Register].

NOTE: Check the link:https://github.com/theodi/BDNS/branches[development branches] for the latest abbreviations

All devices should have a Device ID even if their communication is handled by a Device Gateway.
The optional prefix is strongly encouraged.

Example Device IDs:

* `GB-LON-BLD2_TSTAT-1` First thermostat in the UK, London, building `BLD2`.
* `JE-JE3-BLD1_TPS-75` Seventy fifth temperature sensor in Jersey, postcode district 3, building `BLD1`

An optional suffix can also be used as required.

* `GB-LON-BLD2_TSTAT-1_RH-2-3-25-CO2` 

=== Device Gateways

The most straightforward scenario is a device connecting to one of ABC-RP’s protocol endpoints directly via IP based network infrastructure.
For this to work, the device needs to use a supported communication protocol. For the ABC-RP stack MQTT is recommended.

In some cases, a device may not be able to directly connect to one of these protocol endpoints. An example is a device that uses a serial bus or radio waves for local communication. Such devices can be connected to a protocol endpoint by means of a device gateway which acts on behalf of the device(s) when communicating with the cloud.

Device Gateways have the `BDNS` abbreviation `CGW`.
For example:

 * `GB-LON-BLD2_CGW-1` First Device Gateway in the UK, London, building `BLD2`.

This gateway, for example, may handle communications for the `GB-LON-BLD2_TSTAT-1` sensor mentioned above.

When creating and modifying Device Gateways they are treated in exactly the same way as Devices.

=== Credentials

You will be provided a Device credentials as part of your onboarding information.

NOTE: Typically we will use `(Username)/password` for authentication.  If you would like to use `PSK` or `X.509 certificate` please let us know.

NOTE: If you intend to onboard many devices we can discuss ways of automating this process.

=== Point naming

link:https://brickschema.org/[Brick Schema]

Each of the devices that we have created will publish various data points.

The naming for these data points should refer to the link:https://brickschema.org/[Brick Schema].

NOTE: The link:https://github.com/theodi/BDNS/blob/master/BDNS_Abbreviations_Register.csv[BDNS register] references appropriate Brick classes for different asset types.

For a `TPS` temperature sensor device we may use Brick data point names from the link:https://brickschema.org/ontology/1.1/classes/Air_Temperature_Sensor[Air Temperature Sensor] subclass of:

* `supply_air_temperature_sensor`
* `zone_air_temperature_sensor`
* `return_air_temperature_sensor`

=== Payload

link:https://github.com/faucetsdn/udmi[UDMI]

When we have identified the point names for our device we need to encode them into a `json` payload.

To do this we will follow the link:https://github.com/faucetsdn/udmi[UDMI] Schema.

TIP: Arup provides a useful helper library link:https://github.com/arupiot/pyudmi[pyudmi] for working with UDMI objects in python.

An example payload for our Jersey temperature sensor `JE-JE3-BLD1_TPS-75` using the above point names may look something like the below:

[source,json]
----
{
  "version": 1,
  "timestamp": "2019-01-17T14:02:29.364Z",
  "points": {
    "supply_air_temperature_sensor": {
      "present_value": 20.30108642578125
    },
    "zone_air_temperature_sensor": {
      "present_value": 17.23421412344333
    },
    "return_air_temperature_sensor": {
      "present_value": 18.23423567344323
    }
  }
}
----

NOTE: If developing a Device Gateway you would construct a separate payload for each child device that the gateways communicates on behalf of. 

== Channel

When using the recommended MQTT Endpoint the MQTT topic can be set by the device to indicate which *data stream* and event belongs to.

For example when the device sends telemetry to the cloud we would expect this channel or topic to be set to `pointset`.

== Site model

link:https://github.com/faucetsdn/udmi[UDMI Project Site Model]

link:https://github.com/faucetsdn/udmi_site_model[Template UDMI site model]

A project "site model" contains information necessary to specify the configuration for a particular site.
This is a logical representation of the underlying information, and can be applied against different cloud projects or device configurations to ensure that things are configured appropriately.
It's fundamentally the building model that describes the on-prem devices and how they communicate with the cloud.

NOTE: The site model is typically developed between ABC-RP and those being onboarded.
It can be used to populate the device registry and to verify payloads that are received.

== Publishing Data to the MQTT Endpoint

We will be using the UDMI payload schema so will need to serialising timestamps accordingly.  To generate such an example timestamps in bash run the following code:

[source,bash]
----
# Generate Z-notation "Zulu" UTC timestamp + ms
$ date --utc +%FT%T.%3NZ
----

NOTE: For an example of serialising timestamps in `python` review `pyudmi's` link:https://github.com/arupiot/pyudmi/blob/0.0.3/src/udmi/base.py#L73[serialise_timestamp] function.

Now we have a timestamp we can create a simulated payload for our device and send it over the MQTT protocol:

[source,bash]
----
$ mqtt pub -v -h mqtt.facilities.abc-rp.com -p 443 \
  -u 'JE-JE3-BLD1_TPS-75@swansea-iot' -pw 'my-strong-password' \
  -s --cafile ./dstrootx3.pem -t pointset -m '{
  "version": 1,
  "timestamp": 2020-11-16T17:35:56.747Z,
  "points": {
    "supply_air_temperature_sensor": {
      "present_value": 20.30108642578125
    },
    "zone_air_temperature_sensor": {
      "present_value": 17.23421412344333
    },
    "return_air_temperature_sensor": {
      "present_value": 18.23423567344323
    }
  }
}'
----

Overview of above command:

|===
|Option |Description

|`pub`
|Publish a message

|`-h`
|The hostname of the message broker

|`-p`
|The port of the message broker

|`-u`
|The username for authentication

|`-pw`
|The password for authentication

|`-s`
|Use default ssl configuration if no other ssl options are specified

|`--cafile`
|Path to a file containing trusted CA certificates to enable encrypted communication `DST Root CA X3`

|`-t`
|The topic to publish to which will be used as the channel

|`-m`
|The message to publish is UDMI format

|`-V`
|The mqtt version used by the client (v5 and v3.1.1 protocols supported)
|===
